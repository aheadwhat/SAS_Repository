
/*********************************week 2************************************/

data work.earn;
   value = 10;
   do year = 1 to 10;
      interest =  0.5;
      value + year;
      interest + value + 1;
      output;
   end;

run;

data work.newEarn;
   count + 1;
run;

proc print data = earn;
run;

data test;
   set earn;
   call missing(new_val);
   if _n_ = 1 then new_val + 1;
run;


data test;
   set earn;
   retain new_val;
   if _n_ = 1 then new_val = new_val + 1;
run;

/* so implicit assignment accepting operations on the missing value*/




/***************************week 5***************************/
data test1;
input id income$ seed;
datalines;
1 100 100
2 111 1
3 333 33
4 444 444
;
run;



data test2; 
input id income$ seed;
datalines;
1 105 2
5 118 22
;
run;




/*rename?*/
data test1;
   modify test1 test2(rename = (income = new_income));
   by id;
   
   select(_iorc_);
      when(%sysrc(_dsenmr)) do;
        income = new_income;  
        output;
        _error_ = 0;
      end;

      when(%sysrc(_sok)) do;
         replace;
      end;
      otherwise do;
         put 'unexpectional error';
      end;

   end;
run;



proc sort data = test1;
   by id;
run;

proc sort data = test2;
   by id;
run;

data test3;
   set test1 test2;
  by id;
   if last.id;
run;


/**********************************week 6*********************************/
data test;
   input id income flag$ tag age;
   datalines;
   1 100 a 1 11
   3 1000 b 0  22
   4 323 c 0 33
   5 0 . 1 2
   ;

run;


data test1;
   input id income tag;
   datalines;
   4 12 1 
   5 8 0
   6 9 2
   ;

run;

/*debug the point usage*/
data tmp;
   stpoint = 3;
   set test point = stpoint curobs = cobs;
   orig_obs = cobs;
   output;
   stop;
run;


data join;
   set test;
   if _n_ > 3 then set test1;
run;


data join;
   set test1;
   if _n_ > 2 then set test;
run;

data join;
   set test;
    set test1;
run;

data test2;
   input id age;
   datalines;
   1 3
   3 20
   ;
run;

data join;
   if _n_ = 1 then set test2;
   set test;
run;

data join;
   set test2;
   set test;
run;


%let sp = 5;

proc format;
   value fmt 1-&sp = 1 &sp<-high = 2;
run;

data test;
   set test2;
   format age fmt.;
run;


%let i = 1;
proc format;
   value f&i.mt 1-&sp = 1 &sp<-high = 2;
run;


data test;
   set test1;
   format income f&i.mt.;

run;


ods html file = 'E:\hpbin_test.html';
proc hpbin data=test output=binout numbin=2 woe pseudo_quantile;
   target tag;
   input income age;
run;
ods html close;


%macro analysis(i);
   %if &i = 2 or &i = 4 or &i =5  %then %goto exit;
   %put normal;
%exit:%mend;
%analysis(3);


proc format;
   value $fmtt 'a' = 1
            'b' = 2
            'c' = 3
            other = 4;
run;

data test3;
   set test;
   if missing(flag) then flag = -1;
run;




proc iml;
   a = {1 2,3 5};
   b = a`;
   print a b;



%let tmp = 2;
%let x = 3;
data _null_;
   put "tmp&tmp";
   put 'tmp&tmp';
   %put "The value of x is '&x'." ;
   %put 'The value of x is "&x".' ;
run;


data measurement;
   dsid = open('work.test');
   nobs = attrn(dsid, 'nobs');
   nvars = attrn(dsid, 'nvars');
run;

ods trace on;
proc sql;
   select * from measurement;
quit;
ods trace off;




DATA giant;
   INFILE 'C:\Users\chenguanghua\Desktop\LSB\5data\MyRawData\GiantTom.dat' DSD;
   INPUT Name :$15. Color $ Days Weight @@;
RUN;
* Trace PROC MEANS;
ODS TRACE ON;
PROC MEANS DATA = giant;
   BY Color;
RUN;
ODS TRACE OFF;


data test3;
   do i = 1 to 2;
      output;
   end;
run;



/*simulate the accumulating sum*/
data cumsum;
   set test;
   retain cumsum 0;
   cumsum = cumsum + income;
run;


data _null_;
   newstr = cats('var ', 2);
   put newstr;
run;


proc sql outobs = 10;
   select * from dictionary.tables;
quit;


proc sql;
   select name from dictionary.columns where memname in ('cumsum', 'CUMSUM');
quit;


data test4;
   set test_3;
   where income > 10;
   drop income; /*lagged adjustment*/
run;




%let new_var = 1;
%put &new_var;


proc iml;
   varName = {[3] '11'};
   do i=1 to 3;
      varName[i] = 'var';
   end;
   print varName;



proc iml;
   varName = "var1":"var2";
   test = varName[1];
   print test;
   print (varName[1:2]); /*what ... why parenthesis*/
   print (varName[1]);




data test5;
   set test1;
   var1 = tag * 2;
   var2 = income * 3;
run;


proc iml;
   varName = "var1":"var2";
   use test5;
   read all var varName into X;
   close test5;

   Prob = {0, 10, 90}/100;
   call qntl(Pctls, X, Prob);
   print Prob Pctls[c=varName];

quit;


data qntl_test;
   input id income age;
   datalines;
   1 1 1
   2 5 3
   3 . 33
   4 11 .
   5 20 33
   6 5 5
   7 5 6 
   8 5 66
   9 5 11
   ;
run;

proc rank data = qntl_test out = qntl_rank groups = 10;
   var income age;
   ranks rank1-rank2;
run;

proc sql;
   select '{'||put(min(age), 12.)||'    '||put(max(age), 12.)||'}' as breakpoints 
   from qntl_rank
   group by rank2;
quit;

proc sql;
   select rank2 as original_rank, min(age) as min_breakpoint, max(age) as max_breakpoint
   from qntl_rank
   group by rank2
   order by rank2;
quit;

ods html;
proc sql;
   select * from qntl_rank;
quit;




data qntl_test;
   input id income grade $;
   datalines;
   1 1 a
   2 0 b
   3 . c
   4 1 a
   5 0 a
   6 1 a
   7 1 a
   8 1 c
   9 0 .
   ;
run;

proc rank data = qntl_test out = qntl_rank groups = 10;
   var income;
   ranks rank;
run;

proc sql;
   select sum(case when income =. then 1 else 0 end)/count(*) as pct_missing from qntl_test group by income;
quit;
/*verifying that case when can be used with GROUP BY operation and can also embed in SUM in that case.*/


proc format;
   value $missfmt ' '= 'missing' '.'= 'missing' other = 'not missing';
   value missfmt .= 'missing' other = 'not missing';
run;


/*simply compress all types of values into two*/
/*output problem still not resovled.*/

/*proc freq data = qntl_test;*/
/* format _CHAR_ $missfmt.;*/
/* tables _CHAR_ /missing missprint nocum;*/
/* format _NUMERIC_ missfmt.;*/
/* tables _NUMERIC_ /list missing missprint nocum out=misspct;*/
/*run;*/
/**/

proc sql;
   select count(*) into: att_cnt from qntl_test;
quit;

%macro misspct;
   proc sql;
      create table r_qntl_test as 
      select income as var1, grade as var2
      from qntl_test;
   quit;
   %do i = 1 %to 2;
      proc sql;
         create table mis&i as
         select "var&i" as varname, sum(case when missing(var&i) then 1 else 0 end)/&att_cnt as misspct from r_qntl_test;
      quit;
   %end;
   data misspct;
      set mis1-mis2;
   run;
   proc sort data = misspct;
      by misspct;
   run;
   %do i = 1 %to 2;
      proc sql;
         drop table mis&i;
      quit;
   %end;
%mend misspct;
%misspct;


/*try to skip the %do routine mentioned above*/

%macro misspct(start_idx, end_idx, inputdata);
   data _null_;
      length str $1000; /*change according the specific scene*/
      str = 'proc sql; create table misspct as select ';
      str1 = 'sum(case when missing(';
      str2 =  ') then 1 else 0 end)/&obs_cnt as misspct_';
      do i = &start_idx to &end_idx;
         if i = &start_idx then do;
            str = catx(' ', str, str1);
            str = cats(str,'var', i, str2, i);
         end;
         else str = cats(str, str1,'var', i, str2, i);
         
         if i ne &end_idx then str = cats(str, ", ");
         else str = catx(' ',str,' from &inputdata; quit;');
      end;
      put str;
      call execute(str);
   run;

%mend misspct;

data test_cat;
   input id var1 var2 $ var3;
   datalines;
   1 1 a 1
   2 0 b 1
   3 . c 3
   4 1 a 4
   5 0 a 6
   6 1 a 6
   7 1 a 76
   8 1 c 6
   9 0 . .
   ;
run;

proc sql;
   select count(*) into: obs_cnt from &inputdata;
quit;


%let inputdata = test_cat;
%misspct(1,3,&inputdata);



/*reshaping the result*/
proc transpose data = misspct out = misspct_r;
run;

/*other way to transpose*/


/*test functionality of getting var name*/


/*test cat and so on*/
data _null_;
   length str $1000; /*crucial*/
   do i = 1 to 2;
      str = cats(str, 'var', i);
      if i ne 2 then str = cats(str, ", ");     
   end;
   put str;
run;



data _null_;
   x='  The   Olym'; 
   y='pic Arts Festi';
   z='  val includes works by D  ';
   a='ale Chihuly.';
   result=cats(x, y, z, a);
   result1=cat(x,y,z,a); /*trim with left operation*/
   result2=catt(x,y,z,a); /*directly trim and connect*/
   result3=catx('*',x,y,z,a); /*insert the seperator*/
   put result $char.; 
   put result1 $char.;
   put result2 $char.; 
   put result3 $char.;
run;



/*test the scope of the variable */
/*for macro %misspct(..), what will happen if the inut variables have been defined as global variables*/
/*local macro scope here! Not affect the global macro*/
%let start_idx = 1;
%let end_idx = 2;
%misspct(2,3,&inputdata);
%put &end_idx;



/*test shortcut connnection*/
%let start_idx = 1;
%let end_idx = 3;
data test3 test2;
   set test1;
run;
data test;
   set test&start_idx - test&end_idx;
run;


%let file = test1;
%macro check;
   %if %sysfunc(exist(&file)) %then
      %put file exist: "&file";
   %else %put file doesn't exist;
%mend check;
%check

%check

/*if run in one time, the macro prog doesn't execute?*/
/*but if write the %check double times, it works!*/

%let file = test1;
%macro check(name);
   %if %sysfunc(exist(&name)) %then
      %put file exist: "&name";
   %else %put file doesn't exist;
%mend check;

%check(&file)

%put file: &file;
%put file;

data _null_;
   put "what";
run;





data test_missing;
   input id income;
   datalines;
   1 2
   3 4
   5 6
   6 .
   8 .
   ;
run;

data test_missing;
   set test_missing;
   where not missing(income);
run;



data test5;
   input id income;
   datalines;
   1 3
   1 4
   1 6
   1 6
   1 .
   1 .
   ;
run;

data test5;

run;

data test5;
   set test5;
   by income;
   if last.income;
run; 

proc rank data = test5 out = test_rank group = 4;
   var income;
   ranks rank;
run;

data test1;
   input id income;
/* datalines;*/
/* 1 2*/
/* 3 4 */
/* 5 6*/
/* ;*/
   datalines;
   1 2
   3 4 
   ;
run;

data test2;
   input id new_id $;
   datalines;
   1 a
   3 b
   ;
run;

data test3;
   input new_id$ age;
   datalines;
   a 12
   b 33
   c 44
   d 55
   h 3
   ;
run; 

proc sql;
   select t1.id, t3.* from test1 as t1
   left join test2 as t2
   on t1.id = t2.id
   left join test3 as t3
   on t2.new_id = t3.new_id;
quit;


/*test demo for tagsort*/
data test;
   input id income age;
   dataline;
   1 100 3
   2 40 2
   3 55 5
   4 66 9
   5 40 1
   1 55 2
   ;
run;

data temp;
   set test(keep = income age);
   recno = _n_;
run;

proc sort data = temp;
   by income age;
run;

data test1;
   set temp(keep = recno);
   set test point = recno;
   drop recno;
run;


/* point and stop*/
/*data a;*/
/*set sashelp.class(rename=(name=name1 age=age1 sex=gender height=ht1 weight=wt1));*/
/*run;*/
/**/
/*data w;*/
/*set sashelp.class;*/
/*do i=1 to nobs by 3;*/
/*set a point=i nobs= nobs;*/
/**/
/*output;stop;*/
/*end;*/
/*run;*/

proc datasets library = work kill memtype = data;
quit;
run;

%macro splitsort(libref =, dataset =, num =, var=);
data _null_;
   if 0 then set &libref..&dataset nobs = count;
   call symput('numobs', put(count, 8.));
run;

%let n=%sysevalf(&numobs/&num,ceil);

data %do J=1 %to &num; dataset_&J %end; ;
set &libref..&dataset;;
   %do I = 1 %to &num;
   if %eval(&n*(&I-1)) <_n_ <= %eval(&n*&I)
   then output dataset_&I;
   %end;
run;
   
%do J = 1 %to &num;
   proc sort data = dataset_&J;
      by &var;
   run;
%end;
/**/
/*data sorted_dataset;*/
/* set %do J = 1 %to &num; dataset_&J %end; ;*/
/*    by &var;*/
/*run;*/


/* **slight modification is needed when wanting to unduplicate the original dataset.*/
/*data sorted_dataset;*/
/* set %do J = 1 %to &num; dataset_&J %end; ;*/
/* by &var;*/
/* if last.%scan(&var, 1 ,' ');*/
/*run;*/

data sorted_dataset;
   set dataset_1 - dataset_&num;
   by &var;
   if last.%scan(&var, 1 ,' ');
/* where %scan(&var, 1, ' ') ne 2;*/
run;

%mend splitsort;
/*%splitsort(libref = sashelp, dataset = class, num = 3, var = Name age weight);*/
%splitsort(libref = work, dataset = test, num = 3, var = id age income);


ods select none;
proc contents data=sashelp._all_;
   ods output members=m;
run;
ods select all;

proc print;
   where memtype = 'DATA';
run;



/*try to combine sum and tag at the same time*/

proc format;
   value dmy 0 = 0 
           other = 1;
run;

data test;
   input id ovd_days;
   datalines;
   1 10
   2 300
   3 0 
   ;
run;

/*missing test*/
/*data test;*/
/* input id ovd_days;*/
/* datalines;*/
/* 1 10 */
/* 1 22*/
/* 2 .*/
/* 2 .*/
/* 3 0*/
/* ;*/
/*run;*/

proc sql;
   create table info_tag as 
      select id, sum(ovd_days) as ovd_days, 0/0 as zerodivsion
      from test
      group by id;
quit;

proc sql;
   create table info_tag as 
      select id, sum(ovd_days) as ovd_days format dmy.
      from test
      group by id;
quit;

proc sql;
   create table temp as 
      select id, sum(ovd_days) as ovd_days
      from test
      group by id;
   create table info_tag as 
      select id, (case when ovd_days > 0 then 1 else 0 end) as tag
      from temp;
quit;
 



/*macro parameter passing test*/
%macro pass(var1, var2);
proc sql;
   select * from test where &var1 = 1;
quit;
%mend pass;
%pass(id);

 
%macro pass(idx, prefix);
%let var3 = &prefix&idx;
%put var3 = &var3;
proc sql;
   select * from test where &var3 = 1;
quit;
%mend;
%pass(d,i);


/*test combining uneven number tagged datasets*/
/*first, generate some sample data and then create a character list (kept in global marco) to save the tags*/
data test1 test2 test3 test4;
   input id age;
   datalines;
   1 2
   1 11
   ;
run;

/*option symbolgen;*/
data _null_;
   length str $100;
   do i = 1 to 4;
      if i = 2 then continue;
      str = catx(' ', str, i);
   end;
   call symput('strlist', str);
run;

%put &strlist;
/*%put _user_;*/

/*%let strlist = %str(1 3 4);*/
data _null_;
   length digits $6;
/* string = &strlist;*/
/* put 'string =' string;*/
   do until(digits = ' ');
      count + 1;
/*    digits = scan("&strlist", count);*/
      digits = scan(&strlist, count);

      put digits;
   end;
run;


%let x = 1;
data _null_;
   m = max(max(&x,3),4);
   put m;
run;


/*local ... test*/

%macro data_join(start_idx=,end_idx=,del=(2));
   data _null_;
      do i = &start_idx to &end_idx;
         if i not in &del then put i;
      end;
   run;  

%mend data_joion;
%data_join(start_idx=1, end_idx=5, del= (2,3));
%data_join(start_idx=2, end_idx=5, del=(2,3));
%data_join(start_idx=1, end_idx=5);




data test_1;
   input id ovd_days;
   datalines;
   1 10
   2 300
   3 0 
   ;
run;

data test_2;
   input id ovd_days;
   datalines;
   1 10
   2 300
   3 0 
   ;

run;


data new_test;
   set test_:;
run;

/*ods testing*/
ods html file = 'E:\select.html';
proc sql;
   select * from test;
quit;
ods html close;


%let i = test;
data test_macro;
   set work.&i;
run;


data _null_;
   do i=1 to 3;
      if i in (1,2) then 
      put i;
   end;
run;



proc datasets;
/* delete test:;*/
   delete test_1:test_2;
run;

%let idx_list = %str(1,2); /*crux, when by '', how to understand*/
%macro genidx;
   %let count = 1;
   %do %while(%scan(&idx_list, &count) ne );
      delete test%scan(&idx_list, &count);
      %let count = %eval(&count + 1);
   %end;
   
%mend genidx;
%genidx;

proc datasets;
   %genidx;
run;

%let temp = %scan(&idx_list, 2); /*what if considering the third param?*/
%put &temp  &idx_list;

%let idx_list = "11 12";/*not work!*/
%let temp = %scan(&idx_list, 2); 
%put &temp;

%put %scan("12 32", 2);


/*another round to test*/
/*order and semi-colon should be handled carefully */
%macro genidx(idx_list =);
   %let count = 1;
   %do %while(%scan(&idx_list, &count) ne );
      %let count = %eval(&count + 1);
      test%scan(&idx_list, %eval(&count-1)) 
   %end;
   
%mend genidx;
%genidx;

proc datasets;
   delete %genidx(idx_list = %str(1,2));
run;

data _null;
   set %genidx(idx_list = %str(3,4));
run;



libname dataset 'E:\SAS Codes\temp_lib';
data dataset.test1;
   set test1;
run;
data dataset.test2;
   set test2;
run;

proc datasets library = dataset;
   delete %genidx(idx_list = %str(1,2));
run;



/*test ods tagsets.excelxp*/
ods tagsets.excelxp file="E:\test.xls";
ods tagsets.excelxp options(autofilter="yes");
proc print data = test3;run;
proc print data = test4;run;
ods tagsets.excelxp close;



proc sql;
   select count(id) from _null;
quit;


data html_analysis;
/* length varname $60.;*/
   infile 'E:\hpbin_test.html';
   input @'Information Value</th>' @;
   do i = 1 to 2;
   input @'<th class="l rowheader" scope="row">' string: $256.;
   varname = scan(string,1,'<');
   input @'class="r data">' +1 iv: $10.@;
   iv = input(scan(iv, 1, '<'),Best12.);
   output;
   end;
   drop string;
run;


%let filename = E:;
ods html file = "&filename\test.html";
proc sql;
   select * from html_analysis;
quit;
ods html close;
